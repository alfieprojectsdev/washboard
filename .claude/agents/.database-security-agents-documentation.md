# Prompt Engineering Documentation: database-manager & security-auth Agents

This document describes the prompt engineering patterns applied to both new agents created 2024-10-24.

---

## database-manager.md (500+ lines)

### Prompt Engineering Patterns Applied

#### 1. **Emphasis Hierarchy** (RULE 0 with Penalties)
**Location:** Lines 16-23
```markdown
## RULE 0 (MOST IMPORTANT): Correctness first, then performance

NEVER sacrifice data integrity for speed (-$2000 penalty).
NEVER optimize without measuring first (-$1000 penalty).
```

**Why:** Establishes priority (correctness > speed) and blocks ADHD hyperfocus on optimization
**Expected Impact:** Prevents premature optimization (the specific problem identified in parkboard)
**Pattern Source:** All agents use RULE 0; penalties from quality-reviewer

---

#### 2. **Scale-Appropriate Decision Matrix**
**Location:** Lines 275-285 (Denormalization Decision Matrix)

**Pattern:**
```markdown
| Read:Write Ratio | Query Time | Action |
|------------------|------------|--------|
| <3:1 | Any | Keep normalized |
| 3:1 to 10:1 | <50ms | Keep normalized |
| >10:1 | >100ms | Consider denormalization |
```

**Why:** Provides concrete thresholds to prevent "this could be faster" optimization
**Expected Impact:** Blocks premature denormalization decisions
**Pattern Source:** Architect's decision matrices; customized for database scale

**Real-world application (parkboard example):**
```
parkboard scale: 400 users × 5 bookings/month = 2k/year
Query time with JOIN: 5ms
Read:Write: 3:1
Matrix says: "Keep normalized"
Result: Denormalization was premature
```

---

#### 3. **Measurement-First Protocol**
**Location:** Lines 177-210 (Query Optimization Process)

**Pattern:**
```markdown
### Step 1: Measure First
EXPLAIN ANALYZE [query]

### Step 2: Identify Bottleneck
- Missing index? → Add index
- Expensive JOIN? → Consider denormalization (if read-heavy)

### Step 3: Validate Improvement
- Measure improvement (50ms → 5ms = good)

### Step 4: Document Decision
-- Why this index exists (for future maintainers)
```

**Why:** Forces evidence-based optimization (blocks "feels slow" optimizations)
**Expected Impact:** All optimizations traceable to measurements
**Pattern Source:** Debugger's evidence-gathering protocol adapted for databases

---

#### 4. **Technology-Specific Sections**
**Location:** Lines 31-50 (Database Technologies)

**Pattern:**
```markdown
### PostgreSQL (Primary Expertise)
- Advanced features: Triggers, RLS, EXCLUDE constraints

### Prisma ORM
- Schema optimization, N+1 query detection

### Supabase
- RLS policy design, Realtime performance
```

**Why:** Contextual expertise (adapts advice to tech stack)
**Expected Impact:** Agent gives PostgreSQL-specific advice (triggers) vs MySQL (stored procedures)
**Pattern Source:** Conditional logic from prompt-engineering.md

---

#### 5. **Constraint Design as Documentation**
**Location:** Lines 110-122 (Schema Design Principles)

**Pattern:**
```sql
CREATE TABLE bookings (
  CHECK (end_time > start_time),  -- Business rule enforced
  EXCLUDE USING gist (...) -- Prevents double-booking at DB level
);
```

**Why:** Constraints are executable specifications (prevent invalid data at DB level)
**Expected Impact:** Agent recommends constraints for business rules, not just app-level validation
**Pattern Source:** Architect's "constraints as documentation" principle

---

#### 6. **Anti-Pattern Examples** (NEVER Section)
**Location:** Lines 475-483

**Pattern:**
```markdown
## NEVER Do These
- NEVER denormalize without measuring query performance (-$1000)
- NEVER add indexes without understanding query patterns (-$500)
- NEVER sacrifice data integrity for speed (-$2000)
```

**Why:** Explicit forbidden patterns with penalties (blocks common mistakes)
**Expected Impact:** Prevents ADHD-driven "let's optimize everything!" hyperfocus
**Pattern Source:** All agents have NEVER/ALWAYS sections; penalties from BashTool pattern

---

#### 7. **When to Invoke This Agent** (Scope Limitation)
**Location:** Lines 25-35

**Pattern:**
```markdown
**✅ USE database-manager for:**
- Query optimization (slow queries identified)
- Denormalization decisions (when JOIN is proven slow)

**❌ DON'T USE database-manager for:**
- Simple CRUD operations (@developer handles this)
- Generic "make it faster" requests (measure first, then ask)
```

**Why:** Prevents overuse (agent isn't called for trivial tasks)
**Expected Impact:** Users measure first, then invoke agent with evidence
**Pattern Source:** Security-auth's scope limitation pattern

---

#### 8. **Rollback-First Migration Strategy**
**Location:** Lines 405-430 (Migration Strategies)

**Pattern:**
```sql
-- migration_001_up.sql
ALTER TABLE bookings ADD COLUMN notes TEXT;

-- migration_001_down.sql (ALWAYS provide)
ALTER TABLE bookings DROP COLUMN notes;
```

**Why:** Every migration must be reversible (safety)
**Expected Impact:** No "oh no, can't rollback" moments in production
**Pattern Source:** Debugger's "provide rollback strategy" principle

---

### Behavioral Impact Predictions

1. **Reduced premature optimization** - Scale matrix blocks "let's make it faster" without measurements
2. **Measurement-driven decisions** - EXPLAIN ANALYZE required before optimization advice
3. **Safer migrations** - Rollback scripts prevent irreversible changes
4. **Appropriate constraints** - Business rules enforced at DB level (not just app)
5. **Scale-aware design** - Different advice for 1k vs 1M rows

---

## security-auth.md (600+ lines)

### Prompt Engineering Patterns Applied

#### 1. **Extreme Emphasis Hierarchy** (RULE 0 with Graduated Penalties)
**Location:** Lines 16-24
```markdown
## RULE 0 (MOST IMPORTANT): Assume breach, verify everything

Client-side auth checks are UX only, NOT security (-$2000 penalty).
Trusting client-provided user IDs = critical security failure (-$3000 penalty).
```

**Why:** Security failures are catastrophic (penalties reflect severity)
**Expected Impact:** Agent NEVER trusts client, always verifies server-side
**Pattern Source:** BashTool's -$1000 penalty; scaled up for security criticality

**Graduated penalties:**
- General security mistake: -$2000
- Critical security failure: -$3000
- Storing plaintext passwords: -$5000 (from agent content)

---

#### 2. **Checklist-Driven Reviews**
**Location:** Lines 515-530 (Security Review Checklist)

**Pattern:**
```markdown
### Authentication Review
- [ ] Passwords hashed with bcrypt (cost factor 10-12)
- [ ] Rate limiting on login endpoint
- [ ] Session regeneration after login
- [ ] OAuth state parameter used (CSRF protection)
```

**Why:** Comprehensive checklist prevents missed security issues
**Expected Impact:** Every auth system reviewed against same standard
**Pattern Source:** Developer's implementation checklist adapted for security

---

#### 3. **Vulnerability-Specific Examples** (VULNERABLE vs SECURE)
**Location:** Lines 395-445 (Common Auth Vulnerabilities)

**Pattern:**
```typescript
// VULNERABLE: Reuse session ID after login
req.session.userId = user.id; // ❌ Attacker set session ID

// SECURE: Regenerate session ID after login
await req.session.regenerate(); // ✅ New session ID
req.session.userId = user.id;
```

**Why:** Concrete examples of what NOT to do (with explanations)
**Expected Impact:** Users recognize vulnerable patterns in existing code
**Pattern Source:** Example-driven pattern from prompt-engineering.md

**Covers 4 common vulnerabilities:**
1. Session fixation
2. Insecure password reset
3. OAuth redirect URI attack
4. Price manipulation (payment-adjacent security)

---

#### 4. **Technology-Specific Patterns**
**Location:** Lines 31-45 (Authentication Technologies)

**Pattern:**
```markdown
### NextAuth.js
- Session strategies (JWT vs database)
- OAuth provider configuration

### Supabase Auth
- RLS integration
- Magic link authentication

### Custom Auth
- Password hashing (bcrypt, argon2)
- JWT design (access + refresh)
```

**Why:** Different auth providers = different security concerns
**Expected Impact:** Agent adapts advice to NextAuth vs Supabase vs custom
**Pattern Source:** Database-manager's technology sections

---

#### 5. **Multi-Layered Security** (Defense-in-Depth)
**Location:** Lines 170-210 (Authorization Patterns)

**Pattern:**
```typescript
// Layer 1: Middleware (server-side)
if (!session) return redirect('/login');

// Layer 2: RLS (database-level)
CREATE POLICY ... USING (renter_id = auth.uid());

// Layer 3: Resource ownership (API route)
if (userId !== session.user.id) return 403;
```

**Why:** Single security layer can fail; defense-in-depth provides redundancy
**Expected Impact:** Agent recommends multiple security layers
**Pattern Source:** Quality-reviewer's "defense-in-depth" principle

---

#### 6. **Integration with Other Agents**
**Location:** Lines 593-607

**Pattern:**
```markdown
## Integration with Other Agents

**With @database-manager:**
- RLS policy design (server-side enforcement)
- Denormalized fields for RLS performance

**With @quality-reviewer:**
- General security (XSS, SQL injection)
- This agent focuses on auth-specific security
```

**Why:** Clarifies boundaries (reduces agent overlap confusion)
**Expected Impact:** Users know when to use security-auth vs quality-reviewer
**Pattern Source:** Plan-execution's agent delegation guidance

---

#### 7. **Payment-Adjacent Security**
**Location:** Lines 430-470 (Price Manipulation Vulnerability)

**Pattern:**
```typescript
// VULNERABLE: Client sends total_price
const { total_price } = req.body; // ❌ Trusting client

// SECURE: Server calculates price
const slot = await db.slot.findUnique({ where: { id } });
const total_price = slot.price_per_hour * duration; // ✅ Server-side

// BEST: Database trigger (see @database-manager)
```

**Why:** Marketplace apps need to prevent price manipulation
**Expected Impact:** Catches parkboard-style security issues (trigger pattern)
**Pattern Source:** Real-world example from parkboard analysis

---

#### 8. **Constant-Time Comparison** (Timing Attack Prevention)
**Location:** Lines 87-100 (Email/Password Pattern)

**Pattern:**
```typescript
// Constant-time comparison (prevent timing attack)
const isValid = user
  ? await bcrypt.compare(password, user.password_hash)
  : await bcrypt.compare(password, '$2b$10$fake.hash'); // Dummy

if (!user || !isValid) {
  return { error: 'Invalid credentials' }; // Generic error
}
```

**Why:** Timing attacks can reveal "user not found" vs "wrong password"
**Expected Impact:** Agent catches subtle timing vulnerabilities
**Pattern Source:** Security best practices (OWASP)

---

### Behavioral Impact Predictions

1. **Zero client trust** - Every auth decision verified server-side (RULE 0 enforcement)
2. **Defense-in-depth** - Multiple security layers recommended (middleware + RLS + API checks)
3. **Vulnerability awareness** - Concrete examples help users recognize vulnerable patterns
4. **OAuth security** - State parameter, redirect URI validation, PKCE for mobile
5. **Payment security** - Server-side price calculation prevents manipulation

---

## Cross-Agent Synergies

### database-manager + security-auth

**RLS Performance Optimization:**
```
security-auth designs: RLS policy with user ownership check
database-manager optimizes: Denormalize owner_id to avoid subquery in RLS
Result: Secure AND fast
```

**Example from parkboard:**
```sql
-- security-auth: Ensure users only see their bookings
CREATE POLICY bookings_select
  USING (slot_owner_id = auth.uid());

-- database-manager: Add denormalized field for RLS performance
ALTER TABLE bookings ADD COLUMN slot_owner_id UUID;
CREATE TRIGGER set_slot_owner_id ...;

-- Combined: Secure policy that's also fast (no JOIN in RLS)
```

### database-manager + architect

**Schema Design Collaboration:**
```
architect: Design booking system schema
database-manager: Add EXCLUDE constraint for temporal overlap prevention
Result: Business rules enforced at DB level
```

### security-auth + quality-reviewer

**Security Review Boundaries:**
```
quality-reviewer: General security (SQL injection, XSS, error handling)
security-auth: Auth-specific (OAuth security, session management, RBAC)
Result: Comprehensive security coverage without overlap
```

---

## Techniques NOT Applied (Intentionally)

### 1. **Extreme Conciseness**
**Why not:** Security and database topics require detailed explanations
**Trade-off:** Longer agent prompts, but comprehensive coverage prevents mistakes

### 2. **Parallel Tool Execution**
**Why not:** These are analysis/review agents, not execution agents
**Trade-off:** Git workflows use parallel; these agents use sequential reasoning

### 3. **Meta-Prompting/Sub-Agents**
**Why not:** These are specialist leaf-level agents (don't delegate further)
**Trade-off:** Plan-execution delegates to these agents; they don't delegate onward

---

## Compliance Summary

| Aspect | database-manager | security-auth | Notes |
|--------|------------------|---------------|-------|
| Frontmatter format | ✅ | ✅ | Matches all agents |
| RULE 0 pattern | ✅ | ✅ | With graduated penalties |
| CLAUDE.md integration | ✅ | ✅ | Project-specific standards |
| Reward/penalty system | ✅ | ✅ | -$500 to -$5000 range |
| NEVER/ALWAYS sections | ✅ | ✅ | Behavioral constraints |
| Output format examples | ✅ | ✅ | Concrete templates |
| plan-execution.md integration | ✅ | ✅ | Added to agent list |
| Progressive disclosure | ✅ | ✅ | Basic → Advanced patterns |
| Scope limitation | ✅ | ✅ | When to invoke vs not |
| Technology-specific | ✅ | ✅ | PostgreSQL vs Prisma, NextAuth vs Supabase |

---

## Real-World Application: Parkboard Retrospective

### What database-manager Would Have Caught

**Before (with overengineering):**
```sql
-- Denormalized slot_owner_id
ALTER TABLE bookings ADD COLUMN slot_owner_id UUID;
-- Composite indexes
CREATE INDEX idx_bookings_renter_status_time ...;
```

**database-manager review:**
```markdown
❌ Denormalized slot_owner_id:
   Scale check: 2k bookings/year
   Query time: 5ms with JOIN
   ROI: Saves 2ms on low-frequency queries

   RECOMMENDATION: Remove. Add ONLY if you measure >50ms query times.
```

**Result:** Simpler schema, same performance

---

### What security-auth Would Have Caught

**Before (OAuth added for "better UX"):**
```
Added: Google OAuth, Facebook OAuth, profile completion flow
Complexity: +3 files, +OAuth credentials management
```

**security-auth review:**
```markdown
⚠️  OAuth implementation:
   For condo marketplace (400 known users):
   - Email/password sufficient
   - OAuth is UX enhancement, not security requirement

   RECOMMENDATION: OAuth correctly implemented, but consider removing
   for MVP simplicity. Add back if user testing shows value.
```

**Result:** Conscious decision to keep or remove (not default "yes")

---

## Portfolio Value Assessment

| Agent | Net Value | Primary Beneficiary | Secondary Benefit |
|-------|-----------|---------------------|-------------------|
| database-manager | **+$400** | parkboard (526-line schema) | pipetgo (quotation system redesign) |
| security-auth | **+$600** | parkboard (production OAuth) | pipetgo (RBAC design) |

**Combined Portfolio Value: +$1000**

**Justified because:**
1. ✅ 2/3 projects have auth (pipetgo, parkboard)
2. ✅ Parkboard is production-ready (real security stakes)
3. ✅ Prevents ADHD-driven overengineering (scale-appropriate design)
4. ✅ Orthogonal to existing agents (minimal overlap)

---

## Testing the Agents

### Test Case 1: database-manager (Parkboard Denormalization)

**Input:**
```
@database-manager: Should I denormalize slot_owner_id in bookings table?

Context:
- 400 users, ~2k bookings/year
- Current query: SELECT * FROM bookings JOIN slots ... (5ms)
- Read:write ratio: 3:1
```

**Expected output:**
```markdown
**Denormalization Analysis:**

Scale check: 2k bookings/year = 10k rows in 5 years
Query time: 5ms (measured with EXPLAIN ANALYZE)
Read:write ratio: 3:1

Decision Matrix:
| Read:Write | Query Time | Action |
| 3:1 | 5ms | Keep normalized |

RECOMMENDATION: ❌ Do NOT denormalize

RATIONALE:
- Query is already fast (5ms < 50ms threshold)
- Scale is small (10k rows in 5 years)
- Read:write ratio too low (need >10:1 for denormalization)

Add denormalization ONLY if:
✅ Production metrics show >50ms query times
✅ Scale reaches 100k+ bookings
✅ Read:write ratio >10:1

Current design: Simple JOIN is appropriate for scale
```

---

### Test Case 2: security-auth (OAuth Security)

**Input:**
```
@security-auth: Review my OAuth callback implementation

[provides code with missing state parameter validation]
```

**Expected output:**
```markdown
**Security Review: OAuth Implementation**

❌ CRITICAL: Missing state parameter validation
   Location: auth/callback.ts:12
   Impact: CSRF vulnerability - attacker can hijack OAuth flow
   Fix: Verify state parameter matches session-stored value

Example fix:
```typescript
const { state } = req.query;
const validState = await verifyState(state, req.session.id);
if (!validState) {
  return Response.json({ error: 'Invalid state' }, { status: 400 });
}
```

✅ Redirect URI validated (good)
✅ Tokens stored server-side (good)

Overall Security: 6/10 (critical CSRF vulnerability)
**BLOCK PRODUCTION** until state parameter validation added.
```

---

**Conclusion:** Both agents successfully apply prompt engineering patterns to prevent real-world mistakes (premature optimization, security vulnerabilities) identified in the parkboard retrospective.
